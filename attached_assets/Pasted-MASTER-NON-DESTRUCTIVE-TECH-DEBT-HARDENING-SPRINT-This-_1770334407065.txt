MASTER NON-DESTRUCTIVE TECH-DEBT + HARDENING SPRINT

This is a phased refactor and hardening pass across the application.

CRITICAL RULES
- Do NOT change endpoint paths, request shapes, or response shapes unless explicitly instructed.
- Do NOT change database schema except additive migrations.
- Do NOT remove features.
- Do NOT refactor UI or product logic.
- Behavior must remain identical unless fixing a bug or enforcing validation/security.
- After EACH phase:
  - typecheck
  - build
  - run tests (if present)
  - update docs
  - STOP before continuing

If a step is unclear, prefer documentation over code changes.

========================================================
PHASE 0 — INVENTORY BASELINE (DOCUMENTATION ONLY)
========================================================

Read:
docs/AUDIT_FINDINGS.md
docs/KNOWN_ISSUES.md
docs/PERFORMANCE_NOTES.md
docs/SECURITY_RATE_LIMITS.md

Create:
/docs/REFACTOR/ROADMAP_BASELINE.md

Include:
- Full route inventory (method + path)
- Duplicated middleware/helpers locations
- Storage responsibilities in server/storage.ts
- Current error response variations
- POST/PATCH routes lacking validation
- Current rate limiting scope
- Test failures (FK cleanup + port binding)
- Tenant scoping inconsistencies

STOP after doc creation.

========================================================
PHASE 1 — SECURITY + TENANCY HARDENING
========================================================

1. SESSION_SECRET validation
- Fail fast in production if SESSION_SECRET missing.
- Dev fallback allowed.
- Update App Docs: Required env vars.

2. Tenant scoping consistency
- Create canonical tenant middleware:
  server/middleware/tenant.ts
- Centralize getEffectiveTenantId.
- Replace inconsistent usage safely.
- Produce /docs/SECURITY/TENANCY_AUDIT.md.

3. Rate limiting improvements
- Clarify docs to reflect current auth-only rate limiting.
- Expand limiter to:
  - auth flows
  - invite/create user
  - chat send
  - admin mutations
- Add optional Redis-backed limiter support.
- Fallback to in-memory limiter if Redis absent.
- Update docs/SECURITY_RATE_LIMITS.md.

Verify server boots and tests pass.

STOP.

========================================================
PHASE 2 — API CONSISTENCY + VALIDATION
========================================================

1. Standardize error responses
Adopt one shape:
{
  "error": {
    "code": "...",
    "message": "...",
    "requestId": "..."
  }
}

- Use AppError + centralized error middleware.
- Update routes to use error utilities.
- Do not change success payloads.
- Update App Docs: API Error Format.

2. Ensure validation coverage
- Every POST/PATCH must use validateBody() with Zod schema.
- Add missing schemas where needed.
- Ensure validation errors use standardized error shape.

Verify build + tests.

STOP.

========================================================
PHASE 3 — TEST RELIABILITY
========================================================

1. Fix FK cleanup order
- Implement safe cleanup helper or fixtures.
- Update failing tests.

2. Introduce app factory
- server/app.ts exports createApp()
- server/index.ts only listens.
- Tests import createApp().

3. Add integration coverage
Add tests for:
- Clients CRUD
- Projects CRUD
- Tasks/Subtasks CRUD
- Time entries CRUD
Include:
- auth checks
- tenant isolation
- RBAC validation

Verify tests stable.

STOP.

========================================================
PHASE 4 — MAINTAINABILITY & MODULARITY
========================================================

1. Consolidate middleware
Create:
server/middleware/requireAuth.ts
server/middleware/tenant.ts

Remove duplicate implementations.

2. Split oversized route files
Break into:
server/routes/*.routes.ts
server/routes/superAdmin/*.routes.ts

Keep endpoints identical.
Create:
docs/REFACTOR/ROUTES_AFTER_SPLIT.md

3. Split storage layer
Create:
server/storage/
  base.ts
  clientStorage.ts
  projectStorage.ts
  taskStorage.ts
  timeEntryStorage.ts
  chatStorage.ts
  commentStorage.ts
  userStorage.ts

Re-export composed storage object from server/storage/index.ts.

Verify app boots and CRUD flows still work.

STOP.

========================================================
PHASE 5 — PERFORMANCE IMPROVEMENTS
========================================================

1. Add DB indexes from docs/PERFORMANCE_NOTES.md
Add migrations only.
Create:
/docs/PERFORMANCE/INDEX_CHANGES.md

2. Batch loading improvements
Implement batching for:
- time entries
- activity logs
- comments/attachments

Ensure response shapes unchanged.

STOP.

========================================================
PHASE 6 — OBSERVABILITY
========================================================

Create:
/docs/OBSERVABILITY/ACTIVITY_LOG_POLICY.md

Ensure activity logging exists for:
- client CRUD
- project CRUD
- task/subtask CRUD
- time entry CRUD
- admin actions

Add minimal tests confirming logs are written.

STOP.

========================================================
PHASE 7 — DEVELOPER EXPERIENCE
========================================================

Fix TypeScript request augmentation.

Add:
server/types.d.ts

Extend Express.Request with:
- effectiveTenantId
- user
- requestId

Create:
/docs/DEV/REQUEST_TYPES.md

Verify typecheck clean.

STOP.

========================================================
FINAL OUTPUT
========================================================

Provide:
- list of files created/modified
- phases completed
- migrations added
- tests added
- remaining technical debt items
- any deferred work
